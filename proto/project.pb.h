// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: project.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_project_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_project_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_project_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_project_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_project_2eproto;
namespace beatsgame {
class Exitgame;
struct ExitgameDefaultTypeInternal;
extern ExitgameDefaultTypeInternal _Exitgame_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Match;
struct MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class OP;
struct OPDefaultTypeInternal;
extern OPDefaultTypeInternal _OP_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class REnter;
struct REnterDefaultTypeInternal;
extern REnterDefaultTypeInternal _REnter_default_instance_;
class RExitgame;
struct RExitgameDefaultTypeInternal;
extern RExitgameDefaultTypeInternal _RExitgame_default_instance_;
class RLogin;
struct RLoginDefaultTypeInternal;
extern RLoginDefaultTypeInternal _RLogin_default_instance_;
class RMatch;
struct RMatchDefaultTypeInternal;
extern RMatchDefaultTypeInternal _RMatch_default_instance_;
class ROperation;
struct ROperationDefaultTypeInternal;
extern ROperationDefaultTypeInternal _ROperation_default_instance_;
}  // namespace beatsgame
PROTOBUF_NAMESPACE_OPEN
template<> ::beatsgame::Exitgame* Arena::CreateMaybeMessage<::beatsgame::Exitgame>(Arena*);
template<> ::beatsgame::Login* Arena::CreateMaybeMessage<::beatsgame::Login>(Arena*);
template<> ::beatsgame::Match* Arena::CreateMaybeMessage<::beatsgame::Match>(Arena*);
template<> ::beatsgame::OP* Arena::CreateMaybeMessage<::beatsgame::OP>(Arena*);
template<> ::beatsgame::Operation* Arena::CreateMaybeMessage<::beatsgame::Operation>(Arena*);
template<> ::beatsgame::REnter* Arena::CreateMaybeMessage<::beatsgame::REnter>(Arena*);
template<> ::beatsgame::RExitgame* Arena::CreateMaybeMessage<::beatsgame::RExitgame>(Arena*);
template<> ::beatsgame::RLogin* Arena::CreateMaybeMessage<::beatsgame::RLogin>(Arena*);
template<> ::beatsgame::RMatch* Arena::CreateMaybeMessage<::beatsgame::RMatch>(Arena*);
template<> ::beatsgame::ROperation* Arena::CreateMaybeMessage<::beatsgame::ROperation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace beatsgame {

enum Command : int {
  pushJ = 0,
  pullJ = 1,
  pushK = 2,
  pullK = 3,
  pushL = 4,
  pullL = 5,
  pushU = 6,
  pullU = 7,
  pushI = 8,
  pullI = 9,
  pushO = 10,
  pullO = 11,
  none = 12,
  Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Command_IsValid(int value);
constexpr Command Command_MIN = pushJ;
constexpr Command Command_MAX = none;
constexpr int Command_ARRAYSIZE = Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_descriptor();
template<typename T>
inline const std::string& Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_descriptor(), enum_t_value);
}
inline bool Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
// ===================================================================

class Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  explicit PROTOBUF_CONSTEXPR Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Login& from) {
    Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.Login";
  }
  protected:
  explicit Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kRegisterFieldNumber = 1,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // bool register = 1;
  void clear_register_();
  bool register_() const;
  void set_register_(bool value);
  private:
  bool _internal_register_() const;
  void _internal_set_register_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    bool register__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class RLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.RLogin) */ {
 public:
  inline RLogin() : RLogin(nullptr) {}
  ~RLogin() override;
  explicit PROTOBUF_CONSTEXPR RLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RLogin(const RLogin& from);
  RLogin(RLogin&& from) noexcept
    : RLogin() {
    *this = ::std::move(from);
  }

  inline RLogin& operator=(const RLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline RLogin& operator=(RLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const RLogin* internal_default_instance() {
    return reinterpret_cast<const RLogin*>(
               &_RLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RLogin& a, RLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(RLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RLogin& from) {
    RLogin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.RLogin";
  }
  protected:
  explicit RLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // uint32 success = 2;
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.RLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    uint32_t success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.Match) */ {
 public:
  inline Match() : Match(nullptr) {}
  ~Match() override;
  explicit PROTOBUF_CONSTEXPR Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Match(const Match& from);
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline Match& operator=(Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }
  inline void Swap(Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Match& from) {
    Match::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.Match";
  }
  protected:
  explicit Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class RMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.RMatch) */ {
 public:
  inline RMatch() : RMatch(nullptr) {}
  ~RMatch() override;
  explicit PROTOBUF_CONSTEXPR RMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RMatch(const RMatch& from);
  RMatch(RMatch&& from) noexcept
    : RMatch() {
    *this = ::std::move(from);
  }

  inline RMatch& operator=(const RMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RMatch& operator=(RMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RMatch* internal_default_instance() {
    return reinterpret_cast<const RMatch*>(
               &_RMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RMatch& a, RMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(RMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RMatch& from) {
    RMatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.RMatch";
  }
  protected:
  explicit RMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // uint32 success = 1;
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.RMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class REnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.REnter) */ {
 public:
  inline REnter() : REnter(nullptr) {}
  ~REnter() override;
  explicit PROTOBUF_CONSTEXPR REnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  REnter(const REnter& from);
  REnter(REnter&& from) noexcept
    : REnter() {
    *this = ::std::move(from);
  }

  inline REnter& operator=(const REnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline REnter& operator=(REnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const REnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const REnter* internal_default_instance() {
    return reinterpret_cast<const REnter*>(
               &_REnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(REnter& a, REnter& b) {
    a.Swap(&b);
  }
  inline void Swap(REnter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(REnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  REnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<REnter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const REnter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const REnter& from) {
    REnter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(REnter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.REnter";
  }
  protected:
  explicit REnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameidFieldNumber = 1,
    kSeedFieldNumber = 2,
  };
  // uint32 gameid = 1;
  void clear_gameid();
  uint32_t gameid() const;
  void set_gameid(uint32_t value);
  private:
  uint32_t _internal_gameid() const;
  void _internal_set_gameid(uint32_t value);
  public:

  // uint32 seed = 2;
  void clear_seed();
  uint32_t seed() const;
  void set_seed(uint32_t value);
  private:
  uint32_t _internal_seed() const;
  void _internal_set_seed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.REnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t gameid_;
    uint32_t seed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientOperationFieldNumber = 2,
    kFrameFieldNumber = 1,
  };
  // repeated .beatsgame.OP client_operation = 2;
  int client_operation_size() const;
  private:
  int _internal_client_operation_size() const;
  public:
  void clear_client_operation();
  ::beatsgame::OP* mutable_client_operation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >*
      mutable_client_operation();
  private:
  const ::beatsgame::OP& _internal_client_operation(int index) const;
  ::beatsgame::OP* _internal_add_client_operation();
  public:
  const ::beatsgame::OP& client_operation(int index) const;
  ::beatsgame::OP* add_client_operation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >&
      client_operation() const;

  // uint32 frame = 1;
  void clear_frame();
  uint32_t frame() const;
  void set_frame(uint32_t value);
  private:
  uint32_t _internal_frame() const;
  void _internal_set_frame(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP > client_operation_;
    uint32_t frame_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class ROperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.ROperation) */ {
 public:
  inline ROperation() : ROperation(nullptr) {}
  ~ROperation() override;
  explicit PROTOBUF_CONSTEXPR ROperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ROperation(const ROperation& from);
  ROperation(ROperation&& from) noexcept
    : ROperation() {
    *this = ::std::move(from);
  }

  inline ROperation& operator=(const ROperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ROperation& operator=(ROperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ROperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ROperation* internal_default_instance() {
    return reinterpret_cast<const ROperation*>(
               &_ROperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ROperation& a, ROperation& b) {
    a.Swap(&b);
  }
  inline void Swap(ROperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ROperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ROperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ROperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ROperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ROperation& from) {
    ROperation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ROperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.ROperation";
  }
  protected:
  explicit ROperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 3,
    kFrameFieldNumber = 1,
    kDeltatimeFieldNumber = 2,
  };
  // repeated .beatsgame.OP operations = 3;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::beatsgame::OP* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >*
      mutable_operations();
  private:
  const ::beatsgame::OP& _internal_operations(int index) const;
  ::beatsgame::OP* _internal_add_operations();
  public:
  const ::beatsgame::OP& operations(int index) const;
  ::beatsgame::OP* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >&
      operations() const;

  // uint32 frame = 1;
  void clear_frame();
  uint32_t frame() const;
  void set_frame(uint32_t value);
  private:
  uint32_t _internal_frame() const;
  void _internal_set_frame(uint32_t value);
  public:

  // uint32 deltatime = 2;
  void clear_deltatime();
  uint32_t deltatime() const;
  void set_deltatime(uint32_t value);
  private:
  uint32_t _internal_deltatime() const;
  void _internal_set_deltatime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.ROperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP > operations_;
    uint32_t frame_;
    uint32_t deltatime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class Exitgame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.Exitgame) */ {
 public:
  inline Exitgame() : Exitgame(nullptr) {}
  ~Exitgame() override;
  explicit PROTOBUF_CONSTEXPR Exitgame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Exitgame(const Exitgame& from);
  Exitgame(Exitgame&& from) noexcept
    : Exitgame() {
    *this = ::std::move(from);
  }

  inline Exitgame& operator=(const Exitgame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exitgame& operator=(Exitgame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Exitgame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Exitgame* internal_default_instance() {
    return reinterpret_cast<const Exitgame*>(
               &_Exitgame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Exitgame& a, Exitgame& b) {
    a.Swap(&b);
  }
  inline void Swap(Exitgame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exitgame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Exitgame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Exitgame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Exitgame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Exitgame& from) {
    Exitgame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exitgame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.Exitgame";
  }
  protected:
  explicit Exitgame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.Exitgame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class RExitgame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.RExitgame) */ {
 public:
  inline RExitgame() : RExitgame(nullptr) {}
  ~RExitgame() override;
  explicit PROTOBUF_CONSTEXPR RExitgame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RExitgame(const RExitgame& from);
  RExitgame(RExitgame&& from) noexcept
    : RExitgame() {
    *this = ::std::move(from);
  }

  inline RExitgame& operator=(const RExitgame& from) {
    CopyFrom(from);
    return *this;
  }
  inline RExitgame& operator=(RExitgame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RExitgame& default_instance() {
    return *internal_default_instance();
  }
  static inline const RExitgame* internal_default_instance() {
    return reinterpret_cast<const RExitgame*>(
               &_RExitgame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RExitgame& a, RExitgame& b) {
    a.Swap(&b);
  }
  inline void Swap(RExitgame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RExitgame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RExitgame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RExitgame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RExitgame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RExitgame& from) {
    RExitgame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RExitgame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.RExitgame";
  }
  protected:
  explicit RExitgame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // uint32 success = 2;
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.RExitgame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    uint32_t success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// -------------------------------------------------------------------

class OP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:beatsgame.OP) */ {
 public:
  inline OP() : OP(nullptr) {}
  ~OP() override;
  explicit PROTOBUF_CONSTEXPR OP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OP(const OP& from);
  OP(OP&& from) noexcept
    : OP() {
    *this = ::std::move(from);
  }

  inline OP& operator=(const OP& from) {
    CopyFrom(from);
    return *this;
  }
  inline OP& operator=(OP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OP& default_instance() {
    return *internal_default_instance();
  }
  static inline const OP* internal_default_instance() {
    return reinterpret_cast<const OP*>(
               &_OP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OP& a, OP& b) {
    a.Swap(&b);
  }
  inline void Swap(OP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OP& from) {
    OP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "beatsgame.OP";
  }
  protected:
  explicit OP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMoveFieldNumber = 2,
    kMovexFieldNumber = 3,
    kMoveyFieldNumber = 4,
    kDoFieldNumber = 5,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // bool move = 2;
  void clear_move();
  bool move() const;
  void set_move(bool value);
  private:
  bool _internal_move() const;
  void _internal_set_move(bool value);
  public:

  // sint32 movex = 3;
  void clear_movex();
  int32_t movex() const;
  void set_movex(int32_t value);
  private:
  int32_t _internal_movex() const;
  void _internal_set_movex(int32_t value);
  public:

  // sint32 movey = 4;
  void clear_movey();
  int32_t movey() const;
  void set_movey(int32_t value);
  private:
  int32_t _internal_movey() const;
  void _internal_set_movey(int32_t value);
  public:

  // .beatsgame.Command do = 5;
  void clear_do_();
  ::beatsgame::Command do_() const;
  void set_do_(::beatsgame::Command value);
  private:
  ::beatsgame::Command _internal_do_() const;
  void _internal_set_do_(::beatsgame::Command value);
  public:

  // @@protoc_insertion_point(class_scope:beatsgame.OP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    bool move_;
    int32_t movex_;
    int32_t movey_;
    int do__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_project_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Login

// bool register = 1;
inline void Login::clear_register_() {
  _impl_.register__ = false;
}
inline bool Login::_internal_register_() const {
  return _impl_.register__;
}
inline bool Login::register_() const {
  // @@protoc_insertion_point(field_get:beatsgame.Login.register)
  return _internal_register_();
}
inline void Login::_internal_set_register_(bool value) {
  
  _impl_.register__ = value;
}
inline void Login::set_register_(bool value) {
  _internal_set_register_(value);
  // @@protoc_insertion_point(field_set:beatsgame.Login.register)
}

// string username = 2;
inline void Login::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:beatsgame.Login.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beatsgame.Login.username)
}
inline std::string* Login::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:beatsgame.Login.username)
  return _s;
}
inline const std::string& Login::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Login::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:beatsgame.Login.username)
  return _impl_.username_.Release();
}
inline void Login::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beatsgame.Login.username)
}

// string password = 3;
inline void Login::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:beatsgame.Login.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:beatsgame.Login.password)
}
inline std::string* Login::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:beatsgame.Login.password)
  return _s;
}
inline const std::string& Login::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Login::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:beatsgame.Login.password)
  return _impl_.password_.Release();
}
inline void Login::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:beatsgame.Login.password)
}

// -------------------------------------------------------------------

// RLogin

// int32 id = 1;
inline void RLogin::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t RLogin::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RLogin::id() const {
  // @@protoc_insertion_point(field_get:beatsgame.RLogin.id)
  return _internal_id();
}
inline void RLogin::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void RLogin::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beatsgame.RLogin.id)
}

// uint32 success = 2;
inline void RLogin::clear_success() {
  _impl_.success_ = 0u;
}
inline uint32_t RLogin::_internal_success() const {
  return _impl_.success_;
}
inline uint32_t RLogin::success() const {
  // @@protoc_insertion_point(field_get:beatsgame.RLogin.success)
  return _internal_success();
}
inline void RLogin::_internal_set_success(uint32_t value) {
  
  _impl_.success_ = value;
}
inline void RLogin::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:beatsgame.RLogin.success)
}

// -------------------------------------------------------------------

// Match

// int32 id = 1;
inline void Match::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Match::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Match::id() const {
  // @@protoc_insertion_point(field_get:beatsgame.Match.id)
  return _internal_id();
}
inline void Match::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Match::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beatsgame.Match.id)
}

// -------------------------------------------------------------------

// RMatch

// uint32 success = 1;
inline void RMatch::clear_success() {
  _impl_.success_ = 0u;
}
inline uint32_t RMatch::_internal_success() const {
  return _impl_.success_;
}
inline uint32_t RMatch::success() const {
  // @@protoc_insertion_point(field_get:beatsgame.RMatch.success)
  return _internal_success();
}
inline void RMatch::_internal_set_success(uint32_t value) {
  
  _impl_.success_ = value;
}
inline void RMatch::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:beatsgame.RMatch.success)
}

// -------------------------------------------------------------------

// REnter

// uint32 gameid = 1;
inline void REnter::clear_gameid() {
  _impl_.gameid_ = 0u;
}
inline uint32_t REnter::_internal_gameid() const {
  return _impl_.gameid_;
}
inline uint32_t REnter::gameid() const {
  // @@protoc_insertion_point(field_get:beatsgame.REnter.gameid)
  return _internal_gameid();
}
inline void REnter::_internal_set_gameid(uint32_t value) {
  
  _impl_.gameid_ = value;
}
inline void REnter::set_gameid(uint32_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:beatsgame.REnter.gameid)
}

// uint32 seed = 2;
inline void REnter::clear_seed() {
  _impl_.seed_ = 0u;
}
inline uint32_t REnter::_internal_seed() const {
  return _impl_.seed_;
}
inline uint32_t REnter::seed() const {
  // @@protoc_insertion_point(field_get:beatsgame.REnter.seed)
  return _internal_seed();
}
inline void REnter::_internal_set_seed(uint32_t value) {
  
  _impl_.seed_ = value;
}
inline void REnter::set_seed(uint32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:beatsgame.REnter.seed)
}

// -------------------------------------------------------------------

// Operation

// uint32 frame = 1;
inline void Operation::clear_frame() {
  _impl_.frame_ = 0u;
}
inline uint32_t Operation::_internal_frame() const {
  return _impl_.frame_;
}
inline uint32_t Operation::frame() const {
  // @@protoc_insertion_point(field_get:beatsgame.Operation.frame)
  return _internal_frame();
}
inline void Operation::_internal_set_frame(uint32_t value) {
  
  _impl_.frame_ = value;
}
inline void Operation::set_frame(uint32_t value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:beatsgame.Operation.frame)
}

// repeated .beatsgame.OP client_operation = 2;
inline int Operation::_internal_client_operation_size() const {
  return _impl_.client_operation_.size();
}
inline int Operation::client_operation_size() const {
  return _internal_client_operation_size();
}
inline void Operation::clear_client_operation() {
  _impl_.client_operation_.Clear();
}
inline ::beatsgame::OP* Operation::mutable_client_operation(int index) {
  // @@protoc_insertion_point(field_mutable:beatsgame.Operation.client_operation)
  return _impl_.client_operation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >*
Operation::mutable_client_operation() {
  // @@protoc_insertion_point(field_mutable_list:beatsgame.Operation.client_operation)
  return &_impl_.client_operation_;
}
inline const ::beatsgame::OP& Operation::_internal_client_operation(int index) const {
  return _impl_.client_operation_.Get(index);
}
inline const ::beatsgame::OP& Operation::client_operation(int index) const {
  // @@protoc_insertion_point(field_get:beatsgame.Operation.client_operation)
  return _internal_client_operation(index);
}
inline ::beatsgame::OP* Operation::_internal_add_client_operation() {
  return _impl_.client_operation_.Add();
}
inline ::beatsgame::OP* Operation::add_client_operation() {
  ::beatsgame::OP* _add = _internal_add_client_operation();
  // @@protoc_insertion_point(field_add:beatsgame.Operation.client_operation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >&
Operation::client_operation() const {
  // @@protoc_insertion_point(field_list:beatsgame.Operation.client_operation)
  return _impl_.client_operation_;
}

// -------------------------------------------------------------------

// ROperation

// uint32 frame = 1;
inline void ROperation::clear_frame() {
  _impl_.frame_ = 0u;
}
inline uint32_t ROperation::_internal_frame() const {
  return _impl_.frame_;
}
inline uint32_t ROperation::frame() const {
  // @@protoc_insertion_point(field_get:beatsgame.ROperation.frame)
  return _internal_frame();
}
inline void ROperation::_internal_set_frame(uint32_t value) {
  
  _impl_.frame_ = value;
}
inline void ROperation::set_frame(uint32_t value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:beatsgame.ROperation.frame)
}

// uint32 deltatime = 2;
inline void ROperation::clear_deltatime() {
  _impl_.deltatime_ = 0u;
}
inline uint32_t ROperation::_internal_deltatime() const {
  return _impl_.deltatime_;
}
inline uint32_t ROperation::deltatime() const {
  // @@protoc_insertion_point(field_get:beatsgame.ROperation.deltatime)
  return _internal_deltatime();
}
inline void ROperation::_internal_set_deltatime(uint32_t value) {
  
  _impl_.deltatime_ = value;
}
inline void ROperation::set_deltatime(uint32_t value) {
  _internal_set_deltatime(value);
  // @@protoc_insertion_point(field_set:beatsgame.ROperation.deltatime)
}

// repeated .beatsgame.OP operations = 3;
inline int ROperation::_internal_operations_size() const {
  return _impl_.operations_.size();
}
inline int ROperation::operations_size() const {
  return _internal_operations_size();
}
inline void ROperation::clear_operations() {
  _impl_.operations_.Clear();
}
inline ::beatsgame::OP* ROperation::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:beatsgame.ROperation.operations)
  return _impl_.operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >*
ROperation::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:beatsgame.ROperation.operations)
  return &_impl_.operations_;
}
inline const ::beatsgame::OP& ROperation::_internal_operations(int index) const {
  return _impl_.operations_.Get(index);
}
inline const ::beatsgame::OP& ROperation::operations(int index) const {
  // @@protoc_insertion_point(field_get:beatsgame.ROperation.operations)
  return _internal_operations(index);
}
inline ::beatsgame::OP* ROperation::_internal_add_operations() {
  return _impl_.operations_.Add();
}
inline ::beatsgame::OP* ROperation::add_operations() {
  ::beatsgame::OP* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:beatsgame.ROperation.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::beatsgame::OP >&
ROperation::operations() const {
  // @@protoc_insertion_point(field_list:beatsgame.ROperation.operations)
  return _impl_.operations_;
}

// -------------------------------------------------------------------

// Exitgame

// int32 id = 1;
inline void Exitgame::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Exitgame::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Exitgame::id() const {
  // @@protoc_insertion_point(field_get:beatsgame.Exitgame.id)
  return _internal_id();
}
inline void Exitgame::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Exitgame::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beatsgame.Exitgame.id)
}

// -------------------------------------------------------------------

// RExitgame

// int32 id = 1;
inline void RExitgame::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t RExitgame::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RExitgame::id() const {
  // @@protoc_insertion_point(field_get:beatsgame.RExitgame.id)
  return _internal_id();
}
inline void RExitgame::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void RExitgame::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beatsgame.RExitgame.id)
}

// uint32 success = 2;
inline void RExitgame::clear_success() {
  _impl_.success_ = 0u;
}
inline uint32_t RExitgame::_internal_success() const {
  return _impl_.success_;
}
inline uint32_t RExitgame::success() const {
  // @@protoc_insertion_point(field_get:beatsgame.RExitgame.success)
  return _internal_success();
}
inline void RExitgame::_internal_set_success(uint32_t value) {
  
  _impl_.success_ = value;
}
inline void RExitgame::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:beatsgame.RExitgame.success)
}

// -------------------------------------------------------------------

// OP

// int32 id = 1;
inline void OP::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t OP::_internal_id() const {
  return _impl_.id_;
}
inline int32_t OP::id() const {
  // @@protoc_insertion_point(field_get:beatsgame.OP.id)
  return _internal_id();
}
inline void OP::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void OP::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:beatsgame.OP.id)
}

// bool move = 2;
inline void OP::clear_move() {
  _impl_.move_ = false;
}
inline bool OP::_internal_move() const {
  return _impl_.move_;
}
inline bool OP::move() const {
  // @@protoc_insertion_point(field_get:beatsgame.OP.move)
  return _internal_move();
}
inline void OP::_internal_set_move(bool value) {
  
  _impl_.move_ = value;
}
inline void OP::set_move(bool value) {
  _internal_set_move(value);
  // @@protoc_insertion_point(field_set:beatsgame.OP.move)
}

// sint32 movex = 3;
inline void OP::clear_movex() {
  _impl_.movex_ = 0;
}
inline int32_t OP::_internal_movex() const {
  return _impl_.movex_;
}
inline int32_t OP::movex() const {
  // @@protoc_insertion_point(field_get:beatsgame.OP.movex)
  return _internal_movex();
}
inline void OP::_internal_set_movex(int32_t value) {
  
  _impl_.movex_ = value;
}
inline void OP::set_movex(int32_t value) {
  _internal_set_movex(value);
  // @@protoc_insertion_point(field_set:beatsgame.OP.movex)
}

// sint32 movey = 4;
inline void OP::clear_movey() {
  _impl_.movey_ = 0;
}
inline int32_t OP::_internal_movey() const {
  return _impl_.movey_;
}
inline int32_t OP::movey() const {
  // @@protoc_insertion_point(field_get:beatsgame.OP.movey)
  return _internal_movey();
}
inline void OP::_internal_set_movey(int32_t value) {
  
  _impl_.movey_ = value;
}
inline void OP::set_movey(int32_t value) {
  _internal_set_movey(value);
  // @@protoc_insertion_point(field_set:beatsgame.OP.movey)
}

// .beatsgame.Command do = 5;
inline void OP::clear_do_() {
  _impl_.do__ = 0;
}
inline ::beatsgame::Command OP::_internal_do_() const {
  return static_cast< ::beatsgame::Command >(_impl_.do__);
}
inline ::beatsgame::Command OP::do_() const {
  // @@protoc_insertion_point(field_get:beatsgame.OP.do)
  return _internal_do_();
}
inline void OP::_internal_set_do_(::beatsgame::Command value) {
  
  _impl_.do__ = value;
}
inline void OP::set_do_(::beatsgame::Command value) {
  _internal_set_do_(value);
  // @@protoc_insertion_point(field_set:beatsgame.OP.do)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace beatsgame

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::beatsgame::Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::beatsgame::Command>() {
  return ::beatsgame::Command_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_project_2eproto
